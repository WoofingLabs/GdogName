<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gdogarmy NFT</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>
    <script src="https://kit.fontawesome.com/a076d05399.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .flex { display: flex; align-items: center; }
        .items-center { align-items: center; }
        .py-2 { padding: 8px 0; }
        .mr-2 { margin-right: 8px; }
        .w-10 { width: 40px; }
        .h-10 { height: 40px; }
        .rounded { border-radius: 4px; }
        .cursor-pointer { cursor: pointer; }
        button { padding: 8px 16px; margin: 4px; }
        input { padding: 8px; margin: 4px; }
        ul { list-style: none; padding: 0; }
        .error { color: red; }
    </style>
</head>
<body>
    <h1>Gdogarmy NFT</h1>
    <div>
        <button id="connectButton" onclick="connectWallet()">Connect Wallet</button>
        <p>Wallet: <span id="accountAddress">Not connected</span></p>
        <p>Network: <span id="networkStatus">Not connected</span></p>
        <p>GT Balance: <span id="nativeBalance">0</span></p>
        <p>GDOG Balance: <span id="gdogBalance">0</span></p>
        <p>NFT Balance: <span id="nftBalance">0</span></p>
    </div>
    <div>
        <h2>Mint NFT</h2>
        <input type="text" id="nftId" placeholder="Enter NFT ID (1-15 chars)">
        <select id="imageFormat">
            <option value="jpg">JPG</option>
            <option value="png">PNG</option>
        </select>
        <button id="mintButton" onclick="mintNFT()">Mint NFT</button>
    </div>
    <div>
        <h2>Redeem NFT</h2>
        <input type="text" id="tokenId" placeholder="Enter Token ID">
        <button id="redeemButton" onclick="redeemNFT()">Redeem NFT</button>
    </div>
    <div>
        <h2>Your NFTs</h2>
        <ul id="nftList"></ul>
        <button id="batchRedeemButton" onclick="batchRedeemNFT()" disabled>Batch Redeem Selected NFTs</button>
    </div>

    <script>
        const NFT_ADDRESS = "0xE78682D62238e87494386dA733BFF67E4EFbd5A8";
        const GDOG_ADDRESS = "0xf6D9Cf57e20bA0d33372E8998A9424aa53411E04";
        const nftAbi = [
            {"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"isTokenValid","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"string","name":"_id","type":"string"},{"internalType":"string","name":"_imageFormat","type":"string"}],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"release","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenName","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"balance","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"owner","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"tokenOfOwnerByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
        ];
        const gdogAbi = [
            {"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}
        ];

        let web3, account, nftContract, gdogContract;

        async function connectWallet() {
            const status = document.getElementById('networkStatus');
            try {
                if (window.ethereum) {
                    web3 = new Web3(window.ethereum);
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    account = accounts[0];
                    document.getElementById('accountAddress').innerText = account.slice(0, 6) + '...' + account.slice(-4);
                    const chainId = await web3.eth.getChainId();
                    if (chainId !== 10088) {
                        status.innerText = 'Please connect to Gate Layer (Chain ID: 10088)';
                        return;
                    }
                    status.innerText = 'Connected to Gate Layer';
                    nftContract = new web3.eth.Contract(nftAbi, NFT_ADDRESS);
                    gdogContract = new web3.eth.Contract(gdogAbi, GDOG_ADDRESS);
                    await checkBalances();
                } else {
                    status.innerText = 'Please install MetaMask';
                }
            } catch (error) {
                status.innerText = 'Connection failed: ' + error.message;
            }
        }

        async function checkBalances() {
            if (!web3 || !account) return;
            try {
                const nativeBalance = await web3.eth.getBalance(account);
                document.getElementById('nativeBalance').innerText = web3.utils.fromWei(nativeBalance, 'ether');
                const gdogBalance = await gdogContract.methods.balanceOf(account).call();
                document.getElementById('gdogBalance').innerText = web3.utils.fromWei(gdogBalance, 'ether');
                const nftBalance = await nftContract.methods.balanceOf(account).call();
                document.getElementById('nftBalance').innerText = nftBalance;
                await updateNFTList(nftBalance);
            } catch (error) {
                document.getElementById('networkStatus').innerText = 'Balance query failed: ' + error.message;
            }
        }

        async function waitForTransaction(txHash) {
            return new Promise((resolve, reject) => {
                const checkReceipt = async () => {
                    try {
                        const receipt = await web3.eth.getTransactionReceipt(txHash);
                        if (receipt) {
                            if (receipt.status) {
                                resolve(receipt);
                            } else {
                                reject(new Error('Transaction failed'));
                            }
                        } else {
                            setTimeout(checkReceipt, 1000);
                        }
                    } catch (error) {
                        reject(error);
                    }
                };
                checkReceipt();
            });
        }

        async function updateNFTList(nftBalance) {
            const nftList = document.getElementById('nftList');
            nftList.innerHTML = '';
            if (!web3 || !account || nftBalance == 0) {
                nftList.innerHTML = '<li>No NFTs</li>';
                document.getElementById('batchRedeemButton').disabled = true;
                return;
            }
            try {
                for (let i = 0; i < nftBalance; i++) {
                    const tokenId = await nftContract.methods.tokenOfOwnerByIndex(account, i).call();
                    const isValid = await nftContract.methods.isTokenValid(tokenId).call();
                    if (!isValid) continue;
                    const tokenName = await nftContract.methods.tokenName(tokenId).call();
                    const imageUrl = await getNFTImage(tokenId);
                    const li = document.createElement('li');
                    li.className = 'flex items-center py-2';
                    li.innerHTML = `
                        <input type="checkbox" class="nft-checkbox mr-2" value="${tokenId}">
                        <img src="${imageUrl}" alt="NFT ${tokenName}" class="w-10 h-10 rounded mr-2 cursor-pointer" onclick="window.open('${imageUrl}', '_blank')">
                        <span>${tokenName} (ID: ${tokenId})</span>
                    `;
                    nftList.appendChild(li);
                }
                document.getElementById('batchRedeemButton').disabled = nftList.children.length === 0;
            } catch (error) {
                nftList.innerHTML = `<li>Query NFTs failed: ${error.message}</li>`;
                document.getElementById('batchRedeemButton').disabled = true;
            }
        }

        async function getNFTImage(tokenId) {
            try {
                const isValid = await nftContract.methods.isTokenValid(tokenId).call();
                if (!isValid) {
                    return 'https://www.gdoggate.com/nft/default.jpg';
                }
                const tokenURI = await nftContract.methods.tokenURI(tokenId).call();
                const json = JSON.parse(atob(tokenURI.split('data:application/json;base64,')[1]));
                return json.image || 'https://www.gdoggate.com/nft/default.jpg';
            } catch (error) {
                return 'https://www.gdoggate.com/nft/default.jpg';
            }
        }

        async function mintNFT() {
            const status = document.getElementById('networkStatus');
            const mintButton = document.getElementById('mintButton');
            const nftId = document.getElementById('nftId').value.trim();
            const imageFormat = document.getElementById('imageFormat').value;

            if (!web3 || !account) {
                status.innerText = 'Please connect wallet';
                return;
            }
            if (!nftId || nftId.length > 15) {
                status.innerText = 'Enter valid NFT ID (1-15 chars)';
                return;
            }

            try {
                mintButton.disabled = true;
                mintButton.innerHTML = 'Minting... <i class="fa fa-spinner fa-spin ml-2"></i>';
                status.innerText = 'Checking GDOG balance and gas...';

                const gdogBalance = await gdogContract.methods.balanceOf(account).call();
                if (web3.utils.toBN(gdogBalance).lt(web3.utils.toBN('100000000000000000000000'))) {
                    status.innerText = 'Insufficient GDOG balance (need 100000 GDOG)';
                    return;
                }

                const gasPrice = await web3.eth.getGasPrice();
                const estimatedGas = await nftContract.methods.mint(nftId, imageFormat).estimateGas({ from: account });
                const nativeBalance = await web3.eth.getBalance(account);
                const gasCost = web3.utils.toBN(gasPrice).mul(web3.utils.toBN(estimatedGas));
                if (web3.utils.toBN(nativeBalance).lt(gasCost)) {
                    status.innerText = 'Insufficient GT for gas fees';
                    return;
                }

                const tx = await nftContract.methods.mint(nftId, imageFormat).send({
                    from: account,
                    gas: web3.utils.toHex(Math.min(estimatedGas * 2, 3000000))
                });
                await waitForTransaction(tx.transactionHash);

                status.innerText = 'NFT minted successfully!';
                document.getElementById('nftId').value = '';
                await checkBalances();
            } catch (error) {
                status.innerText = error.code === 4001 ? 'User cancelled transaction' : `Mint failed: ${error.message}`;
            } finally {
                mintButton.disabled = false;
                mintButton.innerHTML = 'Mint NFT';
            }
        }

        async function redeemNFT() {
            const status = document.getElementById('networkStatus');
            const redeemButton = document.getElementById('redeemButton');
            const tokenId = document.getElementById('tokenId').value.trim();

            if (!web3 || !account) {
                status.innerText = 'Please connect wallet';
                return;
            }
            if (!tokenId || isNaN(tokenId)) {
                status.innerText = 'Enter valid Token ID';
                return;
            }

            try {
                redeemButton.disabled = true;
                redeemButton.innerHTML = 'Redeeming... <i class="fa fa-spinner fa-spin ml-2"></i>';
                status.innerText = 'Checking Token ID and gas...';

                const owner = await nftContract.methods.ownerOf(tokenId).call();
                if (owner.toLowerCase() !== account.toLowerCase()) {
                    status.innerText = 'You are not the owner of this NFT';
                    return;
                }

                const isValid = await nftContract.methods.isTokenValid(tokenId).call();
                if (!isValid) {
                    status.innerText = 'This NFT is invalid or has been redeemed';
                    return;
                }

                const gasPrice = await web3.eth.getGasPrice();
                const estimatedGas = await nftContract.methods.release(tokenId).estimateGas({ from: account });
                const nativeBalance = await web3.eth.getBalance(account);
                const gasCost = web3.utils.toBN(gasPrice).mul(web3.utils.toBN(estimatedGas));
                if (web3.utils.toBN(nativeBalance).lt(gasCost)) {
                    status.innerText = 'Insufficient GT for gas fees';
                    return;
                }

                const tx = await nftContract.methods.release(tokenId).send({
                    from: account,
                    gas: web3.utils.toHex(Math.min(estimatedGas * 2, 3000000))
                });
                await waitForTransaction(tx.transactionHash);

                status.innerText = 'NFT redeemed successfully!';
                document.getElementById('tokenId').value = '';
                await checkBalances();
            } catch (error) {
                status.innerText = error.code === 4001 ? 'User cancelled transaction' : `Redeem failed: ${error.message}`;
            } finally {
                redeemButton.disabled = false;
                redeemButton.innerHTML = 'Redeem NFT';
            }
        }

        async function batchRedeemNFT() {
            const status = document.getElementById('networkStatus');
            const batchRedeemButton = document.getElementById('batchRedeemButton');
            const checkboxes = document.querySelectorAll('.nft-checkbox:checked');

            if (!web3 || !account) {
                status.innerText = 'Please connect wallet';
                return;
            }
            if (checkboxes.length === 0) {
                status.innerText = 'Select at least one NFT';
                return;
            }

            try {
                batchRedeemButton.disabled = true;
                batchRedeemButton.innerHTML = 'Redeeming... <i class="fa fa-spinner fa-spin ml-2"></i>';
                status.innerText = 'Batch redeeming NFTs...';

                let nativeBalance = await web3.eth.getBalance(account);
                const gasPrice = await web3.eth.getGasPrice();

                for (const checkbox of checkboxes) {
                    const tokenId = checkbox.value;
                    const owner = await nftContract.methods.ownerOf(tokenId).call();
                    if (owner.toLowerCase() !== account.toLowerCase()) {
                        status.innerText = `Token ID ${tokenId} is not your NFT`;
                        return;
                    }

                    const isValid = await nftContract.methods.isTokenValid(tokenId).call();
                    if (!isValid) {
                        status.innerText = `Token ID ${tokenId} is invalid or has been redeemed`;
                        return;
                    }

                    const estimatedGas = await nftContract.methods.release(tokenId).estimateGas({ from: account });
                    const gasCost = web3.utils.toBN(gasPrice).mul(web3.utils.toBN(estimatedGas));
                    if (web3.utils.toBN(nativeBalance).lt(gasCost)) {
                        status.innerText = 'Insufficient GT for gas fees';
                        return;
                    }

                    const tx = await nftContract.methods.release(tokenId).send({
                        from: account,
                        gas: web3.utils.toHex(Math.min(estimatedGas * 2, 3000000))
                    });
                    await waitForTransaction(tx.transactionHash);
                    nativeBalance = await web3.eth.getBalance(account);
                }

                status.innerText = 'Batch redeem successful!';
                document.getElementById('tokenId').value = '';
                await checkBalances();
            } catch (error) {
                status.innerText = error.code === 4001 ? 'User cancelled transaction' : `Batch redeem failed: ${error.message}`;
            } finally {
                batchRedeemButton.disabled = false;
                batchRedeemButton.innerHTML = 'Batch Redeem Selected NFTs';
            }
        }
    </script>
</body>
</html>
